// Code generated by data parser.
// DO NOT EDIT!
package entity

import (
	"encoding/gob"
	"encoding/json"
	"fmt"
	"ngengine/module/object"

	"github.com/mysll/toolkit"
)

var _ = json.Marshal
var _ = toolkit.ParseNumber

// tuple Pos 位置
type PlayerPos_t struct {
	root object.Object

	X float32 //
	Y float32 //
	Z float32 //
}

// tuple Pos construct
func NewPlayerPos(root object.Object) *PlayerPos_t {
	pos := &PlayerPos_t{root: root}
	return pos
}

// tuple Pos equal other
func (pos *PlayerPos_t) Equal(other PlayerPos_t) bool {
	if (pos.X == other.X) && (pos.Y == other.Y) && (pos.Z == other.Z) {
		return true
	}
	return false
}

// Player archive
type PlayerArchive struct {
	root object.Object `xorm:"-"`
	flag int           `xorm:"-"`

	Id   int64
	Name string       `xorm:"varchar(64)"` // 玩家名
	Pos  *PlayerPos_t `xorm:"json"`        // 位置
}

// Player archive construct
func NewPlayerArchive(root object.Object) *PlayerArchive {
	archive := &PlayerArchive{root: root}

	archive.Pos = NewPlayerPos(root)
	return archive
}

// archive table name
func (a *PlayerArchive) TableName() string {
	return "Player"
}

// Player attr
type PlayerAttr struct {
	root object.Object
}

// Player attr construct
func NewPlayerAttr(root object.Object) *PlayerAttr {
	attr := &PlayerAttr{root: root}

	return attr
}

// Player
type Player struct {
	object.ObjectWitness
	archive *PlayerArchive // archive
	attr    *PlayerAttr    // attr
}

// Player construct
func NewPlayer() *Player {
	o := &Player{}
	o.archive = NewPlayerArchive(o)
	o.attr = NewPlayerAttr(o)
	o.Witness(o)
	return o
}

// Player store
func (o *Player) Store() {
}

// Player type
func (o *Player) Type() string {
	return "player"
}

// Player entity name
func (o *Player) Entity() string {
	return "Player"
}

// Player load
func (o *Player) Load() {
}

// get archive
func (o *Player) Archive() *PlayerArchive {
	return o.archive
}

// get attr
func (o *Player) Attr() *PlayerAttr {
	return o.attr
}

// set Name 玩家名
func (o *Player) SetName(name string) {
	if o.archive.Name == name {
		return
	}
	old := o.archive.Name
	o.archive.Name = name
	o.UpdateAttr("Name", name, old)
}

// get Name 玩家名
func (o *Player) Name() string {
	return o.archive.Name
}

// set Pos 位置
func (o *Player) SetPos(pos PlayerPos_t) {
	if o.archive.Pos.Equal(pos) {
		return
	}
	old := *o.archive.Pos
	*o.archive.Pos = pos
	o.UpdateTuple("Pos", pos, old)
}

// get Pos 位置
func (o *Player) Pos() *PlayerPos_t {
	return o.archive.Pos
}

// attr type
func (o *Player) GetAttrType(name string) string {
	switch name {
	case "Name":
		return "string"
	case "Pos":
		return "tuple"
	default:
		return "unknown"
	}
}

// attr expose info
func (o *Player) Expose(name string) int {
	switch name {
	case "Name":
		return object.EXPOSE_OWNER
	case "Pos":
		return object.EXPOSE_OWNER
	default:
		panic("unknown")
	}
}

// get all attr name
func (o *Player) AllAttr() []string {
	return []string{"Name", "Pos"}
}

// get attr index by name
func (o *Player) AttrIndex(name string) int {
	switch name {
	case "Name":
		return 0
	case "Pos":
		return 1
	default:
		return -1
	}
}

// get attr value
func (o *Player) GetAttr(name string) interface{} {
	switch name {
	case "Name":
		return o.archive.Name
	case "Pos":
		return o.archive.Pos
	default:
		return nil
	}
}

// set attr value
func (o *Player) SetAttr(name string, value interface{}) error {
	switch name {
	case "Name":
		if v, ok := value.(string); ok {
			o.SetName(v)
			return nil
		}
		return fmt.Errorf("attr Name type not match")
	case "Pos":
		if v, ok := value.(PlayerPos_t); ok {
			o.SetPos(v)
			return nil
		}
		return fmt.Errorf("attr Pos type not match")
	default:
		return fmt.Errorf("attr %s not found", name)
	}
}

// gob register
func init() {
	gob.Register(&Player{})
	gob.Register(&PlayerArchive{})
	gob.Register([]*Player{})
	gob.Register([]*PlayerArchive{})
}
