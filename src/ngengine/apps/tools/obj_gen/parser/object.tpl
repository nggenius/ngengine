// Code generated by data parser.
// DO NOT EDIT!
package {{.Package}}

import(
    "encoding/json"
	"encoding/gob"
    "fmt"

    "github.com/mysll/toolkit"
)

{{range .Property}}
{{if eq .Type "tuple"}}
// tuple {{.Name}} {{.Desc}}
type {{$.Name}}{{.Name}}_t struct {
    {{range .Tuple}}
	{{.Name}} {{.Type}} // {{.Desc}}{{end}}
}

// tuple {{.Name}} construct
func New{{$.Name}}{{.Name}}() *{{$.Name}}{{.Name}}_t {
	{{tolower .Name}} := &{{$.Name}}{{.Name}}_t{}
	return {{tolower .Name}}
}
{{end}}

{{if eq .Type "table"}}
// record {{.Name}} row define
type {{$.Name}}{{.Name}}_c struct {
    {{range .Table.Cols}}
	{{.Name}} {{.Type}} // {{.Desc}}{{end}}
}

// record {{.Name}} {{.Desc}}
type {{$.Name}}{{.Name}}_r struct {
    Row     []*{{$.Name}}{{.Name}}_c
	data    [{{.Table.MaxRows}}]*{{$.Name}}{{.Name}}_c
	witness TableWitness
}

// record  {{.Name}}  serial
type {{$.Name}}{{.Name}}Json struct{
    ColName []string
    ColType []string
    Row [][]interface{}
}

// record {{.Name}} construct
func New{{$.Name}}{{.Name}}() *{{$.Name}}{{.Name}}_r {
	{{tolower .Name}} := &{{$.Name}}{{.Name}}_r{}
	{{tolower .Name}}.Row = {{tolower .Name}}.data[:0]
	return {{tolower .Name}}
}

// set witness
func (r *{{$.Name}}{{.Name}}_r) SetWitness(w TableWitness) {
	r.witness = w
}

{{$expose := .Expose}}
{{$pname := .Name}}

{{range $index, $col := .Table.Cols}}{{with $col}}
// get {{.Name}}
func (r *{{$.Name}}{{$pname}}_r) {{.Name}}(rownum int) ({{.Type}}, error) {
	if rownum < 0 || rownum >= len(r.Row) {
        return {{if eq .Type "string"}}""{{else}}0{{end}}, fmt.Errorf("row num error")
	}
	return r.Row[rownum].{{.Name}}, nil
}

// set {{.Name}}
func (r *{{$.Name}}{{$pname}}_r) Set{{.Name}}(rownum int, {{tolower .Name}} {{.Type}}) error {
	if rownum < 0 || rownum >= len(r.Row) {
        return fmt.Errorf("row num error")
	}
	if r.Row[rownum].{{.Name}} != {{tolower .Name}} {
		r.Row[rownum].{{.Name}} = {{tolower .Name}}{{if ne $expose ""}}
		if r.witness != nil {
			r.witness.Change("{{$pname}}", rownum, {{$index}}, {{tolower .Name}})
		}{{end}}
	}
	return nil
}
{{end}}{{end}}

// set row value
func (r *{{$.Name}}{{.Name}}_r) SetRowValue(rownum int {{range .Table.Cols}}, {{tolower .Name}} {{.Type}} {{end}} ) error {
	if rownum < 0 || rownum >= len(r.Row) {
		return fmt.Errorf("row num error")
	}
    {{range $index, $col := .Table.Cols}}{{with $col}}
	if r.Row[rownum].{{.Name}} != {{tolower .Name}} {
		r.Row[rownum].{{.Name}} = {{tolower .Name}}{{if ne $expose ""}}
		if r.witness != nil {
			r.witness.Change("{{$pname}}", rownum, {{$index}}, {{tolower .Name}})
		} {{end}}{{end}}
	} {{end}}
	return nil
}

// get row value
func (r *{{$.Name}}{{.Name}}_r) RowValue(rownum int) ({{range .Table.Cols}}{{.Type}},{{end}} error) {
	var row {{$.Name}}{{.Name}}_c
	if rownum < 0 || rownum >= len(r.Row) {
		return {{range .Table.Cols}}row.{{.Name}},{{end}} fmt.Errorf("row num error")
	}

	row = *r.Row[rownum]
	return {{range .Table.Cols}}row.{{.Name}},{{end}} nil
}

// add row
func (r *{{$.Name}}{{.Name}}_r) AddRow(rownum int) (int, error) {
	if len(r.Row) > cap(r.data) { // full
		return -1, fmt.Errorf("record {{$.Name}}{{.Name}} is full")
	}

	if rownum < -1 || rownum >= cap(r.data) { // out of range
		return -1, fmt.Errorf("record {{$.Name}}{{.Name}} row %d out of range", rownum)
	}

	size := len(r.Row)
	row := &{{$.Name}}{{.Name}}_c{}
	r.Row = r.data[:size+1]
	if rownum == -1 || rownum == size {
		r.Row[size] = row{{if ne $expose ""}}
		if r.witness != nil {
			r.witness.AddRow("{{$pname}}", rownum)
		} {{end}}
		return size, nil
	}
	copy(r.Row[rownum+1:], r.Row[rownum:])
	r.Row[rownum] = row	{{if ne $expose ""}}
	if r.witness != nil {
		r.witness.AddRow("{{$pname}}", rownum)
	} {{end}}
	return rownum, nil
}

// add row value
func (r *{{$.Name}}{{.Name}}_r) AddRowValue(rownum int {{range .Table.Cols}}, {{tolower .Name}} {{.Type}} {{end}} ) (int, error) {
	if len(r.Row) > cap(r.data) { // full
		return -1, fmt.Errorf("record {{$.Name}}{{.Name}} is full")
	}

	if rownum < -1 || rownum >= cap(r.data) { // out of range
		return -1, fmt.Errorf("record {{$.Name}}{{.Name}} row %d out of range", rownum)
	}

	size := len(r.Row)
	row := &{{$.Name}}{{.Name}}_c{ {{range $k, $v := .Table.Cols}} {{if ne $k 0}},{{end}} {{tolower .Name}}{{end}} }
	r.Row = r.data[:size+1]
	if rownum == -1 || rownum == size {
		r.Row[size] = row{{if ne $expose ""}}
		if r.witness != nil {
			r.witness.AddRowValue("{{$pname}}", rownum, {{range $k, $v := .Table.Cols}} {{if ne $k 0}},{{end}} {{tolower .Name}}{{end}} )
		} {{end}}
		return size, nil
	}
	copy(r.Row[rownum+1:], r.Row[rownum:])
	r.Row[rownum] = row	{{if ne $expose ""}}
	if r.witness != nil {
		r.witness.AddRowValue("{{$pname}}", rownum, {{range $k, $v := .Table.Cols}} {{if ne $k 0}},{{end}} {{tolower .Name}}{{end}} )
	} {{end}}
	return rownum, nil
}

// del row
func (r *{{$.Name}}{{.Name}}_r) Del(rownum int) error {
	if rownum < 0 || rownum >= len(r.Row) {
		return fmt.Errorf("row num error")
	}
	copy(r.Row[rownum:], r.Row[rownum+1:])
	r.Row = r.data[:len(r.Row)-1]{{if ne $expose ""}}
	if r.witness != nil {
		r.witness.DelRow("{{$pname}}", rownum )
	} {{end}}	
	return nil
}

// clear
func (r *{{$.Name}}{{.Name}}_r) Clear() {
	r.Row = r.data[:0]{{if ne $expose ""}}
	if r.witness != nil {
		r.witness.Clear("{{$pname}}")
	} {{end}}
}

// json encode interface
func (r *{{$.Name}}{{.Name}}_r) Marshal() ([]byte, error) {
    return r.pack()
}

// json decode interface
func (r *{{$.Name}}{{.Name}}_r) Unmarshal(data []byte) error {
    return r.unpack(data)
}

// xorm encode interface
func (r *{{$.Name}}{{.Name}}_r) ToDB() ([]byte, error) {
    return r.pack()
}

// xorm decode interface
func (r *{{$.Name}}{{.Name}}_r) FromDB(data []byte) error {
    return r.unpack(data)
}

// record {{.Name}} pack
func (r *{{$.Name}}{{.Name}}_r) pack() ([]byte, error) {
    j := &{{$.Name}}{{.Name}}Json{}
    j.ColName = make([]string, {{len .Table.Cols}})
    j.ColType = make([]string, {{len .Table.Cols}})
    {{range $k, $v := .Table.Cols}}
    j.ColName[{{$k}}] = "{{$v.Name}}"
    j.ColType[{{$k}}] = "{{$v.Type}}"{{end}}

    j.Row = make([][]interface{}, len(r.Row))
	for k, row := range r.Row {
		if row == nil {
			panic("row is nil")
		}
        j.Row[k] = make([]interface{}, 0, {{len .Table.Cols}})
		j.Row[k] = append(j.Row[k] {{range .Table.Cols}},row.{{.Name}}{{end}})
	}

    return json.Marshal(j)
}

// record {{.Name}} unpack
func (r *{{$.Name}}{{.Name}}_r) unpack(data []byte) error {
    r.Row = r.data[:0]
	j := &{{$.Name}}{{.Name}}Json{}
	err := json.Unmarshal(data, j)
	if err != nil {
		return err
	}

	for _, row := range j.Row {
		if len(r.Row) > cap(r.data) {
			break
		}
		{{tolower $pname}}row := &{{$.Name}}{{.Name}}_c{}
		for k, col := range row {
			switch j.ColName[k] { {{range .Table.Cols}}
			case "{{.Name}}":
				if j.ColType[k] == "{{.Type}}" { {{if eq .Type "string"}}
					{{tolower $pname}}row.{{.Name}} = col.({{.Type}}) {{else}}
                    toolkit.ParseNumber(col, &{{tolower $pname}}row.{{.Name}}) {{end}}
				}{{end}}
			}
		}
		r.Row = r.data[:len(r.Row)+1]
		r.Row[len(row)-1] = toolboxrow
	}
	return nil
}

{{end}}
{{end}}
// {{.Name}} archive
type {{.Name}}Archive struct {
    flag int `xorm:"-"`
    Id int64 {{range .Property}} {{if eq .Save "true"}}
	{{.Name}} {{if eq .Type "tuple"}}*{{$.Name}}{{.Name}}_t `xorm:"json"`{{else if eq .Type "table"}}*{{$.Name}}{{.Name}}_r `xorm:"json"`{{else}}{{.Type}} {{if eq .Type "string"}}`xorm:"varchar({{strsize .}})"`{{end}}{{end}}  // {{.Desc}}{{end}} {{end}}
	witness Witness
}

// {{.Name}} archive construct
func New{{.Name}}Archive() *{{.Name}}Archive {
    archive := &{{.Name}}Archive{}
    {{range .Property}}{{if eq .Save "true"}}
    {{if eq .Type "tuple"}}archive.{{.Name}} = New{{$.Name}}{{.Name}}(){{else if eq .Type "table"}}archive.{{.Name}} = New{{$.Name}}{{.Name}}(){{end}}{{end}}{{end}}
    return archive
}

// archive table name
func (a *{{.Name}}Archive) TableName() string {
    return "{{.Name}}"
}

// set witness
func (a *{{.Name}}Archive) SetWitness(w Witness) {
	a.witness = w
}

// {{.Name}} attr
type {{.Name}}Attr struct{
    {{range .Property}}{{if ne .Save "true"}}
    {{.Name}} {{if eq .Type "tuple"}}{{$.Name}}{{.Name}}_t{{else if eq .Type "table"}}{{$.Name}}{{.Name}}_r{{else}}{{.Type}}{{end}} // {{.Desc}}{{end}}{{end}}
	witness Witness
}

// {{.Name}} attr construct
func New{{.Name}}Attr() *{{.Name}}Attr {
    attr := &{{.Name}}Attr{} 
    {{range .Property}}{{if ne .Save "true"}}
    {{if eq .Type "tuple"}}attr.{{.Name}} = New{{$.Name}}{{.Name}}(){{else if eq .Type "table"}}attr.{{.Name}} = New{{$.Name}}{{.Name}}(){{end}}{{end}}{{end}}
    return attr
}

// set witness
func (a *{{.Name}}Attr) SetWitness(w Witness) {
	a.witness = w
}

// {{.Name}}
type {{.Name}} struct{
    archive *{{.Name}}Archive // archive
    attr *{{.Name}}Attr // attr
	witness Witness // witness
}

// {{.Name}} construct
func New{{.Name}}() *{{.Name}} {
    o := &{{.Name}}{}
    o.archive = New{{.Name}}Archive()
    o.attr = New{{.Name}}Attr()
    return o
}

// get witness
func (o *{{.Name}}) Witness() Witness {
	return o.witness
}

// set witness
func (o *{{.Name}}) SetWitness(w Witness) {
	o.witness = w
	o.archive.SetWitness(w)
	o.attr.SetWitness(w)
}

// {{.Name}} store
func (o *{{.Name}}) Store() {
}

// {{.Name}} load
func (o *{{.Name}}) Load() {
}

// get archive
func (o *{{.Name}}) Archive() *{{.Name}}Archive {
    return o.archive
}

// get attr
func (o *{{.Name}}) Attr() *{{.Name}}Attr {
    return o.attr
}

{{range .Property}}
// set {{.Name}} {{.Desc}}
func (o *{{$.Name}}) Set{{.Name}}( {{tolower .Name}} {{if eq .Type "tuple"}} {{$.Name}}{{.Name}}_t{{else if eq .Type "table"}} *{{$.Name}}{{.Name}}_r {{else}} {{.Type}} {{end}}){
    {{if ne .Type "table"}}{{if eq .Save "true"}}{{if eq .Type "tuple"}}*{{end}}o.archive.{{.Name}} = {{tolower .Name}} {{else}}{{if eq .Type "tuple"}}*{{end}}o.attr.{{.Name}} = {{tolower .Name}} {{end}} {{else}} panic("{{.Name}} can't set") {{end}} {{if ne .Expose ""}} 
	{{if eq .Type "tuple"}}	if o.witness != nil {
		o.witness.GetTupleWitness().Update("{{.Name}}", {{tolower .Name}})
	}{{else if eq .Type "table"}}
	{{else}}if o.witness != nil {
		o.witness.GetAttrWitness().Update("{{.Name}}", {{tolower .Name}})
	} {{end}} {{end}}
}

// get {{.Name}} {{.Desc}}
func (o *{{$.Name}}) {{.Name}}() {{if eq .Type "tuple"}} *{{$.Name}}{{.Name}}_t{{else if eq .Type "table"}} *{{$.Name}}{{.Name}}_r {{else}} {{.Type}} {{end}} {
    {{if eq .Save "true"}}return o.archive.{{.Name}}{{else}}return o.attr.{{.Name}}{{end}}
}
{{end}}

// attr type
func  (o *{{$.Name}}) GetAttrType(name string) string {
	switch name { {{range .Property}}
	case "{{.Name}}":
		return "{{.Type}}" {{end}}
	default:
		return "unknown"
	}
}

// get attr value
func  (o *{{$.Name}}) GetAttr(name string) interface{} {
	switch name { {{range .Property}}
	case "{{.Name}}":
		return {{if eq .Save "true"}}o.archive.{{.Name}} {{else}}o.attr.{{.Name}} {{end}} {{end}}
	default:
		return nil
	}
}

// set attr value
func  (o *{{$.Name}}) SetAttr(name string, value interface{}) error {
	switch name { {{range .Property}}
	case "{{.Name}}": {{if eq .Type "tuple"}}
		if v, ok := value.(*{{$.Name}}{{.Name}}_t); ok {
			o.Set{{.Name}}(v)
			return nil
		} {{else if eq .Type "table"}}
		if v, ok := value.(*{{$.Name}}{{.Name}}_r); ok {
			o.Set{{.Name}}(v)
			return nil
		} {{else}}
		if v, ok := value.({{.Type}}); ok {
			o.Set{{.Name}}(v)
			return nil
		} {{end}}
		return  fmt.Errorf("attr {{.Name}} type not match") {{end}}
	default:
		return fmt.Errorf("attr %s not found", name)
	}
}

// gob register
func init() {
	gob.Register(&{{.Name}}{})
	gob.Register(&{{.Name}}Archive{})
}