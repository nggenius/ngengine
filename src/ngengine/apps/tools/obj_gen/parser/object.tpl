// Code generated by data parser.
// DO NOT EDIT!
package {{.Package}}

import(
    "encoding/json"
    "fmt"

    "github.com/mysll/toolkit"
)

{{range .Property}}
{{if eq .Type "tuple"}}
// tuple {{.Name}} {{.Desc}}
type {{$.Name}}{{.Name}}_t struct {
    {{range .Tuple}}
	{{.Name}} {{.Type}} // {{.Desc}}{{end}}
}

// tuple {{.Name}} construct
func New{{$.Name}}{{.Name}}() *{{$.Name}}{{.Name}}_t {
	{{tolower .Name}} := &{{$.Name}}{{.Name}}_t{}
	return {{tolower .Name}}
}
{{end}}

{{if eq .Type "table"}}
// record {{.Name}} row define
type {{$.Name}}{{.Name}}_c struct {
    {{range .Table.Cols}}
	{{.Name}} {{.Type}} // {{.Desc}}{{end}}
}

// record {{.Name}} {{.Desc}}
type {{$.Name}}{{.Name}}_r struct {
    Row     []*{{$.Name}}{{.Name}}_c
	data    [{{.Table.MaxRows}}]*{{$.Name}}{{.Name}}_c
}

// record  {{.Name}}  serial
type {{$.Name}}{{.Name}}Json struct{
    ColName []string
    ColType []string
    Row [][]interface{}
}

// record {{.Name}} construct
func New{{$.Name}}{{.Name}}() *{{$.Name}}{{.Name}}_r {
	{{tolower .Name}} := &{{$.Name}}{{.Name}}_r{}
	{{tolower .Name}}.Row = {{tolower .Name}}.data[:0]
	return {{tolower .Name}}
}

{{$pname := .Name}}
{{range .Table.Cols}}
// get {{.Name}}
func (r *{{$.Name}}{{$pname}}_r) {{.Name}}(rownum int) ({{.Type}}, error) {
	if rownum < 0 || rownum >= len(r.Row) {
        return {{if eq .Type "string"}}""{{else}}0{{end}}, fmt.Errorf("row num error")
	}
	return r.Row[rownum].{{.Name}}, nil
}

// set {{.Name}}
func (r *{{$.Name}}{{$pname}}_r) Set{{.Name}}(rownum int, {{tolower .Name}} {{.Type}}) error {
	if rownum < 0 || rownum >= len(r.Row) {
        return fmt.Errorf("row num error")
	}
	r.Row[rownum].{{.Name}} = {{tolower .Name}}
	return nil
}
{{end}}

// set row value
func (r *{{$.Name}}{{.Name}}_r) SetRowValue(rownum int {{range .Table.Cols}}, {{tolower .Name}} {{.Type}} {{end}} ) error {
	if rownum < 0 || rownum >= len(r.Row) {
		return fmt.Errorf("row num error")
	}
    {{range .Table.Cols}}
	r.Row[rownum].{{.Name}} = {{tolower .Name}}{{end}}
	return nil
}

// get row value
func (r *{{$.Name}}{{.Name}}_r) RowValue(rownum int) ({{range .Table.Cols}}{{.Type}},{{end}} error) {
	var row {{$.Name}}{{.Name}}_c
	if rownum < 0 || rownum >= len(r.Row) {
		return {{range .Table.Cols}}row.{{.Name}},{{end}} fmt.Errorf("row num error")
	}

	row = *r.Row[rownum]
	return {{range .Table.Cols}}row.{{.Name}},{{end}} nil
}

// add row
func (r *{{$.Name}}{{.Name}}_r) AddRow(rownum int) int {
	if len(r.Row) > cap(r.data) { // full
		return -1
	}

	if rownum < -1 || rownum >= cap(r.data) { // out of range
		return -1
	}

	size := len(r.Row)
	row := &{{$.Name}}{{.Name}}_c{}
	r.Row = r.data[:size+1]
	if rownum == -1 || rownum == size {
		r.Row[size] = row
		return size
	}
	copy(r.Row[rownum+1:], r.Row[rownum:])
	r.Row[rownum] = row
	return rownum
}

// add row value
func (r *{{$.Name}}{{.Name}}_r) AddRowValue(rownum int {{range .Table.Cols}}, {{tolower .Name}} {{.Type}} {{end}} ) int {
	if len(r.Row) > cap(r.data) { // full
		return -1
	}

	if rownum < -1 || rownum >= cap(r.data) { // out of range
		return -1
	}

	size := len(r.Row)
	row := &{{$.Name}}{{.Name}}_c{ {{range $k, $v := .Table.Cols}} {{if ne $k 0}},{{end}} {{tolower .Name}}{{end}} }
	r.Row = r.data[:size+1]
	if rownum == -1 || rownum == size {
		r.Row[size] = row
		return size
	}
	copy(r.Row[rownum+1:], r.Row[rownum:])
	r.Row[rownum] = row
	return rownum
}

// del row
func (r *{{$.Name}}{{.Name}}_r) Del(rownum int) error {
	if rownum < 0 || rownum >= len(r.Row) {
		return fmt.Errorf("row num error")
	}
	copy(r.Row[rownum:], r.Row[rownum+1:])
	r.Row = r.data[:len(r.Row)-1]
	return nil
}

// clear
func (r *{{$.Name}}{{.Name}}_r) Clear() {
	r.Row = r.data[:0]
}

// json encode interface
func (r *{{$.Name}}{{.Name}}_r) Marshal() ([]byte, error) {
    return r.pack()
}

// json decode interface
func (r *{{$.Name}}{{.Name}}_r) Unmarshal(data []byte) error {
    return r.unpack(data)
}

// xorm encode interface
func (r *{{$.Name}}{{.Name}}_r) ToDB() ([]byte, error) {
    return r.pack()
}

// xorm decode interface
func (r *{{$.Name}}{{.Name}}_r) FromDB(data []byte) error {
    return r.unpack(data)
}

// record {{.Name}} pack
func (r *{{$.Name}}{{.Name}}_r) pack() ([]byte, error) {
    j := &{{$.Name}}{{.Name}}Json{}
    j.ColName = make([]string, {{len .Table.Cols}})
    j.ColType = make([]string, {{len .Table.Cols}})
    {{range $k, $v := .Table.Cols}}
    j.ColName[{{$k}}] = "{{$v.Name}}"
    j.ColType[{{$k}}] = "{{$v.Type}}"{{end}}

    j.Row = make([][]interface{}, len(r.Row))
	for k, row := range r.Row {
		if row == nil {
			panic("row is nil")
		}
        j.Row[k] = make([]interface{}, 0, {{len .Table.Cols}})
		j.Row[k] = append(j.Row[k] {{range .Table.Cols}},row.{{.Name}}{{end}})
	}

    return json.Marshal(j)
}

// record {{.Name}} unpack
func (r *{{$.Name}}{{.Name}}_r) unpack(data []byte) error {
    r.Row = r.data[:0]
	j := &{{$.Name}}{{.Name}}Json{}
	err := json.Unmarshal(data, j)
	if err != nil {
		return err
	}

	for _, row := range j.Row {
		{{tolower $pname}}row := &{{$.Name}}{{.Name}}_c{}
		for k, col := range row {
			switch j.ColName[k] { {{range .Table.Cols}}
			case "{{.Name}}":
				if j.ColType[k] == "{{.Type}}" { {{if eq .Type "string"}}
					{{tolower $pname}}row.{{.Name}} = col.({{.Type}}) {{else}}
                    toolkit.ParseNumber(col, &{{tolower $pname}}row.{{.Name}}) {{end}}
				}{{end}}
			}
		}
		r.Row = append(r.Row, {{tolower .Name}}row)
	}
	return nil
}

{{end}}
{{end}}
// {{.Name}} archive
type {{.Name}}Archive struct {
    flag int `xorm:"-"`
    Id int64 {{range .Property}} {{if eq .Save "true"}}
	{{.Name}} {{if eq .Type "tuple"}}*{{$.Name}}{{.Name}}_t `xorm:"json"`{{else if eq .Type "table"}}*{{$.Name}}{{.Name}}_r `xorm:"json"`{{else}}{{.Type}}{{end}}  // {{.Desc}}{{end}} {{end}}
}

// {{.Name}} archive construct
func New{{.Name}}Archive() *{{.Name}}Archive {
    archive := &{{.Name}}Archive{}
    {{range .Property}}{{if eq .Save "true"}}
    {{if eq .Type "tuple"}}archive.{{.Name}} = New{{$.Name}}{{.Name}}(){{else if eq .Type "table"}}archive.{{.Name}} = New{{$.Name}}{{.Name}}(){{end}}{{end}}{{end}}
    return archive
}

// archive table name
func (a *{{.Name}}Archive) TableName() string {
    return "{{.Name}}"
}

// store
func (a *{{.Name}}Archive) Store() error {
    return nil
}

// {{.Name}} attr
type {{.Name}}Attr struct{
    {{range .Property}}{{if ne .Save "true"}}
    {{.Name}} {{if eq .Type "tuple"}}{{$.Name}}{{.Name}}_t{{else if eq .Type "table"}}{{$.Name}}{{.Name}}_r{{else}}{{.Type}}{{end}} // {{.Desc}}{{end}}{{end}}
}

// {{.Name}} attr construct
func New{{.Name}}Attr() *{{.Name}}Attr {
    attr := &{{.Name}}Attr{} 
    {{range .Property}}{{if ne .Save "true"}}
    {{if eq .Type "tuple"}}attr.{{.Name}} = New{{$.Name}}{{.Name}}(){{else if eq .Type "table"}}attr.{{.Name}} = New{{$.Name}}{{.Name}}(){{end}}{{end}}{{end}}
    return attr
}

// {{.Name}}
type {{.Name}} struct{
    archive *{{.Name}}Archive // archive
    attr *{{.Name}}Attr // attr
}

// {{.Name}} construct
func New{{.Name}}() *{{.Name}} {
    o := &{{.Name}}{}
    o.archive = New{{.Name}}Archive()
    o.attr = New{{.Name}}Attr()
    return o
}

// {{.Name}} store
func (o *{{.Name}}) Store() error {
    return o.archive.Store()
}

// get archive
func (o *{{.Name}}) Archive() *{{.Name}}Archive {
    return o.archive
}

// get attr
func (o *{{.Name}}) Attr() *{{.Name}}Attr {
    return o.attr
}

{{range .Property}}
// set {{.Name}} {{.Desc}}
func (o *{{$.Name}}) Set{{.Name}}( {{tolower .Name}} {{if eq .Type "tuple"}} *{{$.Name}}{{.Name}}_t{{else if eq .Type "table"}} *{{$.Name}}{{.Name}}_r {{else}} {{.Type}} {{end}}){
    {{if eq .Save "true"}}o.archive.{{.Name}} = {{tolower .Name}} {{else}}o.attr.{{.Name}} = {{tolower .Name}} {{end}}
}

// get {{.Name}} {{.Desc}}
func (o *{{$.Name}}) {{.Name}}() {{if eq .Type "tuple"}} *{{$.Name}}{{.Name}}_t{{else if eq .Type "table"}} *{{$.Name}}{{.Name}}_r {{else}} {{.Type}} {{end}} {
    {{if eq .Save "true"}}return o.archive.{{.Name}}{{else}}return o.attr.{{.Name}}{{end}}
}
{{end}}
